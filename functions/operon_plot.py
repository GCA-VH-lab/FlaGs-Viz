# FUNCTION FOR CREATING THE OPERON PLOT

# Import packages
import pandas as pd
import dash
import colorsys
import random
import math
import plotly.graph_objs as go
import plotly.figure_factory as ff
from plotly.subplots import make_subplots

# Import specifics
from assets import color_scheme

# Import functions 



# --------------------------- FLAGS COLORS -----------------------------

# Color codes for the operon plot (copied from FlaGs)
def random_color(h=None):
    if not h:
        c = int((random.randrange(0,100,5))*3.6)/100
    d = 0.5
    e = 0.5
    return _hls2hex(c, d, e)
        
def _hls2hex(c, d, e):
	return '#%02x%02x%02x' %tuple(map(lambda f: int(f*255),colorsys.hls_to_rgb(c, d, e)))

def outliner(item):
	if item =='#ffffff':
		return '#bebebe'
	elif item =='#f2f2f2':
		return '#008000'
	elif item =='#f2f2f3':
		return '#000080'
	else:
		return item


color={}
colorDict={}



# ----------------------------- FUNCTIONS ------------------------------

def generate_operon(operon_file):
    '''
    Returns an operon plot figure generated from FlaGs operon.tsv file. 
    Args:
        operon_file: The operon.tsv file generated by FlaGs
    Returns:
        fig: An operon figure
    '''

    # 1. Creating a dictionary to store relevant data from the input file
    operon_data = {
        'organism': [],
        'query_accession': [],
        'gene_accession': [],
        'hmlgs_group': [],
        'gene_direction': [],
        'gene_start': [],
        'gene_end': [],
        'gene_length': [],
        'y_level': [],
    }

    # 1.1. Extracts relevant info from each row
    for g in operon_file.iloc[:, 0]:
        if g != '':
            org = g.split('|')[1]
            operon_data['organism'].append(str(org))

            q_acc = g.split('|')[0]
            operon_data['query_accession'].append(str(q_acc))

    for g in operon_file.iloc[:, 9]:
        if g != '':
            operon_data['y_level'].append(int(0))
            g_acc = g.split('#')[0]
            operon_data['gene_accession'].append(str(g_acc))

    # 1.2 Appends data to the dictionary
    operon_data['hmlgs_group'] = list(operon_file.iloc[:, 4].astype(int))
    operon_data['gene_direction'] = list(operon_file.iloc[:, 3].astype(str))
    operon_data['gene_start'] = list(operon_file.iloc[:, 5].astype(int))
    operon_data['gene_end'] = list(operon_file.iloc[:, 6].astype(int))
    operon_data['gene_length'] = list(operon_file.iloc[:, 1].astype(int))
    
    # 1.3 Turns the dictioanry to a pandas df
    operon_df_org = pd.DataFrame.from_dict(operon_data)

    # 1.4 Adds the y-axis value to all genes of the same operon
    operon_df_org['y_level'] = operon_df_org.groupby('query_accession', sort = False).ngroup()
    operon_df = operon_df_org


    # 2. Instanciating the figure
    fig = go.Figure()

    # 2.1 Creaties empty lists to store all traces
    arrowList = []
    annotations_fam_nr_list = []
    y_tick_marks = []
    labels = []
    row = []

    # 2.2 Iterates through the operon df file and creates variables
    count = 0
    for i, row in operon_df.iterrows():
        organism = operon_df['organism'][i].replace('_', ' ')
        id_q = operon_df['query_accession'][i]
        id_g = operon_df['gene_accession'][i]
        start = operon_df['gene_start'][i]
        end = operon_df['gene_end'][i]
        length = operon_df['gene_length'][i]
        direction = operon_df['gene_direction'][i]
        group_number = operon_df['hmlgs_group'][i]
        y_level = (operon_df['y_level'][i] * 5) * -1

        # 2.2.1 If the gene is too short it adds some extra length,
        # otherwise the arrow will be too small and invert on itself
        if length < 100:
            start = start-50
            end = end+50
        else:
            start = start
            end = end

        # # 2.2.2 Color codes as from the original FlaGs code
        center=int(group_number)+1
        noProt=int(group_number)+2
        noProtP=int(group_number)+3
        noColor=int(group_number)+4

        color[noColor]='#ffffff'
        color[center]='#000000'
        color[noProt]='#f2f2f2'
        color[noProtP]='#f2f2f3'

        if group_number == 0:
            colorDict[group_number]=str('#ffffff')
        elif start == 1:                    
            colorDict[group_number]=str('#000000')
        elif 'pseudogene_' in id_g:
            colorDict[group_number]=str('#f2f2f3') 
        elif 'tRNA_' in id_g:
            colorDict[group_number]=str('#f2f2f2')
        else:
            if group_number not in colorDict:
                colorDict[group_number] = random_color()

        # 2.2.3 Specifying the arrow's dimensions
        arrow_head = 120
        arrow_width = 1.2

        # 2.2.4 Text to show when hovering with the courser over the arrow
        if start == 1 or group_number == 0:
            hover_text = (f'Accession: {id_g}<br>'
                        f'Species: {organism}<br>'
                        f'Length: {length}nt')
        else: 
            hover_text = (f'Accession: {id_g}<br>'
                        f'Species: {organism}<br>'
                        f'Length: {length}nt<br>'
                        f'Homologous group: {group_number}')

        # 2.2.5 Creates arrow coordinates based on the info from the
        # operon .tsv file and stores the in the appropriate list
        if direction == '-':
            xList_gene = [start+arrow_head, 
                        start, start+arrow_head, 
                        end, 
                        end, 
                        start+arrow_head]
            yList_gene = [y_level-arrow_width, 
                        y_level, 
                        y_level+arrow_width, 
                        y_level+arrow_width, 
                        y_level-arrow_width, 
                        y_level-arrow_width]
            arrowList.append(
                fig.add_trace(
                    go.Scatter(x = xList_gene, 
                            y = yList_gene,
                            hoveron = 'fills',
                            hoverinfo = 'text',
                            text = hover_text,
                            fill = 'toself', 
                            fillcolor = colorDict[int(group_number)], 
                            opacity = 0.5,
                            line = (dict(color = outliner(colorDict[group_number]))), 
                            mode = 'lines')))
        else:
            xList_gene = [start, 
                        start, 
                        end-arrow_head, 
                        end, 
                        end-arrow_head, 
                        start]
            yList_gene = [y_level-arrow_width, 
                        y_level+arrow_width, 
                        y_level+arrow_width, 
                        y_level, y_level-arrow_width, 
                        y_level-arrow_width] 
            arrowList.append(
                fig.add_trace(
                    go.Scatter(x = xList_gene, 
                            y = yList_gene,
                            hoveron = 'fills',
                            hoverinfo = 'text',
                            text = hover_text,
                            fill = 'toself', 
                            fillcolor = colorDict[int(group_number)], 
                            opacity = 0.5, 
                            line = (dict(color = outliner(colorDict[group_number]))), 
                            mode = 'lines')))

        # 2.2.6 Displaying the homologous group number inside each arrow
        text_x = start + (length/2.2)
        if group_number != 0 and start != 1 and 'pseudogene_' not in id_g and 'RNA_' not in id_g:
            annotations_fam_nr_list.append(
                fig.add_annotation(
                    x = text_x, 
                    y = y_level, 
                    xref='x', 
                    yref='y', 
                    text = int(group_number), 
                    font = dict(family = 'Helvetica',
                                color = '#73767c', 
                                size = 12), 
                    showarrow = False))
        else:
            pass
   
        if organism not in labels:
            labels += [organism]
            y_tick_marks += [y_level]

    # 3. Scales and sets the graph size
    number_of_queries = (int(len(operon_file.iloc[:, 0].unique()) * 8))
    upper = 10
    lower = (int(number_of_queries) + int(number_of_queries/4)) * -1

    # 4. Creates the opeorn plot
    fig.update_layout(
                    xaxis = dict(visible = False,
                                showgrid = False,
                                showline = False,
                                showticklabels = False),
                    yaxis = dict(visible = False,
                                showgrid = False,
                                showline = False,
                                showticklabels = False, 
                                tickvals = y_tick_marks,
                                ticktext = labels,
                                constrain = 'range',
                                range = [lower, upper],
                                ),
                    margin = dict(l=0,
                                r=0,
                                b=0,
                                t=0,
                                pad=0, 
                                autoexpand = False),
                    showlegend = False, 
                    autosize = False,
                    paper_bgcolor = 'rgba(0,0,0,0)', 
                    plot_bgcolor = 'rgba(0,0,0,0)')

    return fig


def get_operon_graph_dimensions(operon_file):
    '''
    Sets the correct width of the graph container so the correct 
    operon is displayed with its corresponding node on the y-axis level.
    Args:
        operon_file: The operon.tsv file generated by FlaGs
    Returns:
        y_vh: y-level viewport height (%) should the y_vh of the 
        phyogeny plot. 
    '''
    length = len(operon_file.iloc[:, 0].unique()) * 8
    y_vh = str(length) + 'vh'

    return y_vh